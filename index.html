<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>С Днём Рождения</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 1.5s ease-in-out;
        }
        
        body.space-mode {
            background-color: #000;
        }
        
        #timer-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: all 1s ease-in-out;
        }
        
        #timer-container.fade-out {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }
        
        #countdown {
            text-align: center;
            padding: 30px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.1);
            z-index: 10;
            transition: all 0.8s ease-in-out;
        }
        
        .timer-title {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
            transition: all 0.8s ease-in-out;
        }
        
        #timer {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            transition: all 0.8s ease-in-out;
        }
        
        .time-unit {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.8s ease-in-out;
        }
        
        .time-value {
            font-size: 4rem;
            font-weight: bold;
            color: #00ffcc;
            text-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc, 0 0 20px #00ffcc, 0 0 40px #00ffff, 0 0 60px #00ffff, 0 0 100px #00ffff;
            background: rgba(0, 0, 0, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 120px;
            transition: all 0.8s ease-in-out;
        }
        
        .time-label {
            margin-top: 10px;
            font-size: 1.2rem;
            color: #333;
            font-weight: bold;
            transition: all 0.8s ease-in-out;
        }
        
        #target-date {
            font-size: 1.5rem;
            color: #666;
            margin-top: 20px;
            transition: all 0.8s ease-in-out;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: opacity 1.5s ease-in-out;
        }
        
        #confetti-canvas.fade-out {
            opacity: 0;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Стили для анимации после завершения таймера */
        #animation-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            opacity: 0;
            transition: opacity 1.5s ease-in-out 0.5s;
        }
        
        #animation-container.fade-in {
            opacity: 1;
        }

        /* Стили для космической анимации */
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            opacity: 0;
            transform: scale(0.95);
            transition: all 1s ease-in-out 1s;
        }
        
        #container.visible {
            opacity: 1;
            transform: scale(1);
        }
        
        #counter {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.8);
            z-index: 10;
            text-align: center;
            width: 100%;
            letter-spacing: 2px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        #restart-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
        }
        
        .control-btn {
            background: linear-gradient(to bottom, #2a5ba8, #1a3a75);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(0, 100, 255, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease-in-out 2s;
        }
        
        .control-btn.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .control-btn:hover {
            background: linear-gradient(to bottom, #3a7ed5, #2a5ba8);
            box-shadow: 0 0 20px rgba(60, 150, 255, 0.5);
            transform: translateY(-2px);
        }
        
        #restart-btn {
            background: linear-gradient(to bottom, #ff6b6b, #c44545);
            border-radius: 25px;
            width: auto;
            padding: 10px 20px;
            display: flex;
            gap: 8px;
        }
        
        #restart-btn:hover {
            background: linear-gradient(to bottom, #ff8787, #d36c6c);
        }
        
        .control-btn i {
            font-size: 20px;
        }
        
        #textCanvas {
            display: none;
        }
        
        .completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 30px;
            text-align: center;
            text-shadow: 0 0 20px rgba(100, 180, 255, 0.9);
            z-index: 10;
            background: rgba(0, 15, 40, 0.8);
            padding: 20px 40px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        .cake-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff9ecb;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 15px rgba(255, 105, 180, 0.8);
            z-index: 10;
            background: rgba(40, 10, 30, 0.7);
            padding: 15px 30px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }
        
        /* Анимация перехода */
        .transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00, #ff0000);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }
        
        .transition-overlay.active {
            opacity: 1;
        }
        
        .stars-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="20" cy="20" r="1" fill="white" opacity="0.8"/><circle cx="50" cy="30" r="0.5" fill="white" opacity="0.6"/><circle cx="80" cy="40" r="0.8" fill="white" opacity="0.7"/><circle cx="30" cy="70" r="0.6" fill="white" opacity="0.5"/><circle cx="70" cy="80" r="1.2" fill="white" opacity="0.9"/></svg>') repeat;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        
        .stars-bg.visible {
            opacity: 0.3;
        }
        #texte{
            color: rgba(255, 255, 255, 0.9)
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="transition-overlay"></div>
    <div class="stars-bg"></div>
    
    <div id="timer-container">
        <div id="countdown">
            <h1 class="timer-title">До твоего Дня Рождения осталось:</h1>
            <div id="timer">
                <div class="time-unit">
                    <div id="days" class="time-value">00</div>
                    <div class="time-label" id="texte">дней</div>
                </div>
                <div class="time-unit">
                    <div id="hours" class="time-value">00</div>
                    <div class="time-label" id="texte">часов</div>
                </div>
                <div class="time-unit">
                    <div id="minutes" class="time-value">00</div>
                    <div class="time-label" id="texte">минут</div>
                </div>
                <div class="time-unit">
                    <div id="seconds" class="time-value">00</div>
                    <div class="time-label" id="texte">секунд</div>
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="confetti-canvas"></canvas>
    
    <div id="animation-container" class="hidden">
        
    </div>

    <script>
        
        const confettiConfig = {
            particleCount: 150,
            spread: 70,
            origin: { y: 0.6 },
            colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'],
            shapes: ['circle', 'square']
        };
        
     
        const timerContainer = document.getElementById('timer-container');
        const animationContainer = document.getElementById('animation-container');
        const daysElement = document.getElementById('days');
        const hoursElement = document.getElementById('hours');
        const minutesElement = document.getElementById('minutes');
        const secondsElement = document.getElementById('seconds');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const transitionOverlay = document.querySelector('.transition-overlay');
        const starsBg = document.querySelector('.stars-bg');
        const body = document.body;
        const ctx = confettiCanvas.getContext('2d');
        
        
        function setCanvasSize() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        
       
        let confettiParticles = [];
        
        
        function createConfetti() {
            for (let i = 0; i < confettiConfig.particleCount; i++) {
                confettiParticles.push({
                    x: Math.random() * confettiCanvas.width,
                    y: -10 - Math.random() * 20,
                    size: 5 + Math.random() * 10,
                    color: confettiConfig.colors[Math.floor(Math.random() * confettiConfig.colors.length)],
                    shape: confettiConfig.shapes[Math.floor(Math.random() * confettiConfig.shapes.length)],
                    speed: 10 + Math.random() * 5,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    wobble: Math.random() * 10,
                    wobbleSpeed: Math.random() * 0.1
                });
            }
        }
        
        
        function drawConfetti() {
            ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            
            confettiParticles.forEach((particle, index) => {
                ctx.save();
                ctx.translate(particle.x, particle.y);
                ctx.rotate((particle.rotation * Math.PI) / 180);
                
                ctx.fillStyle = particle.color;
                
                if (particle.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, particle.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
                }
                
                ctx.restore();
                
                
                particle.y += particle.speed;
                particle.x += Math.sin(particle.wobble) * 0.5;
                particle.rotation += particle.rotationSpeed;
                particle.wobble += particle.wobbleSpeed;
                
                
                if (particle.y > confettiCanvas.height) {
                    confettiParticles.splice(index, 1);
                }
            });
            
            
            if (confettiParticles.length < confettiConfig.particleCount * 0.7) {
                createConfetti();
            }
        }
        
        
        function animateConfetti() {
            drawConfetti();
            requestAnimationFrame(animateConfetti);
        }
        
        
        const targetDate = new Date('2025-09-27T00:00:00+03:00');
        let timerInterval;

        
        function startSmoothTransition() {
            
            transitionOverlay.classList.add('active');
            
            
            setTimeout(() => {
                
                body.classList.add('space-mode');
                starsBg.classList.add('visible');
                
                
                timerContainer.classList.add('fade-out');
                confettiCanvas.classList.add('fade-out');
                
                
                animationContainer.classList.remove('hidden');
                
            }, 500);
            
            setTimeout(() => {
                
                transitionOverlay.classList.remove('active');
                
                
                animationContainer.classList.add('fade-in');
                
            }, 1200);
            
            setTimeout(() => {
                
                startSpaceAnimation();
            }, 1500);
        }
        
        function updateTimer() {
            const now = new Date();
            const timeDifference = targetDate - now;
            
            if (timeDifference <= 0) {
                startSmoothTransition();
                
                clearInterval(timerInterval);
                return;
            }
            
            const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeDifference % (1000 * 60)) / 1000);
            
            daysElement.textContent = days.toString().padStart(2, '0');
            hoursElement.textContent = hours.toString().padStart(2, '0');
            minutesElement.textContent = minutes.toString().padStart(2, '0');
            secondsElement.textContent = seconds.toString().padStart(2, '0');
        }
        
        function startSpaceAnimation() {
            animationContainer.innerHTML = `
                <div id="container">
                    <div id="counter">Word 1 of 20</div>
                    <div id="controls">
                        <button id="prevBtn" class="control-btn" title="Previous word">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                        <button id="pauseBtn" class="control-btn" title="Pause/Resume">
                            <i class="fas fa-pause"></i>
                        </button>
                    </div>
                    <div id="restart-container">
                        <button id="restart-btn" class="control-btn" title="Restart from beginning">
                            <i class="fas fa-redo"></i>
                            <span>Restart</span>
                        </button>
                    </div>
                    <canvas id="background"></canvas>
                    <canvas id="textCanvas"></canvas>
                    <canvas id="particles"></canvas>
                </div>
            `;
            
            const config = {
                particleCount: 2200,
                particleSize: { min: 1.5, max: 2.5 },
                glowIntensity: 0.6,
                movementSpeed: 0.7,
                twinkleSpeed: 2,
                explosionSpeed: 2,
                colors: ['#FFFFFF', '#F8F8FF', '#E6E6FA', '#B9D7EA', '#A7D2E8', '#FFD700'],
                wordChangeInterval: 5000
            };
            
            const spaceWords = [
                'Дорогая Елизавета!', 'Поздравляю тебя', 'с днём рождения!', 'В этот день', 'хочется пожелать', 
                'космического счастья', 'и', 'невероятных удач.', 'Пусть твоя жизнь', 'будет похожа', 
                'на самое яркое созвездие', '-', 'где каждая', 'звёздочка это', 'радостное событие,',
                'верный друг', 'или', 'исполненная мечта.', 'Пусть твоя', 'собственная звезда',
                'горит особенно ярко,', 'освещая путь', 'к самым смелым целям', 'и', 'озаряя теплом',
                'всех кто', 'рядом с тобой.', 'Будь всегда', 'на', 'своей орбите счастья!!!',
                'Пусть вселенная', 'загадочно улыбается тебе', 'и', 'дарит только', 'добрые знаки.',
                'Обнимаю^^',
                
            ];
            
            const bgCanvas = document.getElementById('background');
            const textCanvas = document.getElementById('textCanvas');
            const particlesCanvas = document.getElementById('particles');
            
            const bgCtx = bgCanvas.getContext('2d');
            const textCtx = textCanvas.getContext('2d');
            const particlesCtx = particlesCanvas.getContext('2d');
            
            const counter = document.getElementById('counter');
            const pauseBtn = document.getElementById('pauseBtn');
            const prevBtn = document.getElementById('prevBtn');
            const restartBtn = document.getElementById('restart-btn');
            const container = document.getElementById('container');
            
            function resizeCanvases() {
                bgCanvas.width = textCanvas.width = particlesCanvas.width = window.innerWidth;
                bgCanvas.height = textCanvas.height = particlesCanvas.height = window.innerHeight;
            }

            let currentWordIndex = 0;
            let wordChangeInterval;
            let currentTextPixels = [];
            let isPaused = false;
            let isExploding = false;
            let animationCompleted = false;
            let completionMessage = null;
            let cakeMessage = null;
            let cakeParticles = [];
            let isCakeActive = false;
            
            function init() {
                resizeCanvases();
                createStarfield();
                createParticles();
                setupEventListeners();
                
                setTimeout(() => {
                    container.classList.add('visible');
                }, 100);
                
                setTimeout(() => {
                    document.querySelectorAll('.control-btn').forEach(btn => {
                        btn.classList.add('visible');
                    });
                }, 2000);
                
                animateText(spaceWords[currentWordIndex]);
                updateCounter();
                
                startAutoChange();
            }
            
            function startAutoChange() {
                if (wordChangeInterval) clearInterval(wordChangeInterval);
                wordChangeInterval = setInterval(() => {
                    if (!isPaused && !isExploding && !animationCompleted) {
                        currentWordIndex++;
                        
                        if (currentWordIndex >= spaceWords.length) {
                            startExplosion();
                            showCompletionMessage();
                            animationCompleted = true;
                            clearInterval(wordChangeInterval);
                        } else {
                            animateText(spaceWords[currentWordIndex]);
                            updateCounter();
                        }
                    }
                }, config.wordChangeInterval);
            }
            
            function startExplosion() {
                isExploding = true;
                
                particles.forEach(particle => {
                    particle.explosionVelX = (Math.random() - 0.5) * config.explosionSpeed;
                    particle.explosionVelY = (Math.random() - 0.5) * config.explosionSpeed;
                    
                    particle.isForming = false;
                });
            }
            
            function showCompletionMessage() {
                if (completionMessage) {
                    completionMessage.remove();
                }
                
                completionMessage = document.createElement('div');
                completionMessage.className = 'completion-message';
                completionMessage.textContent = 'Счастливого времяпровождения';
                document.getElementById('container').appendChild(completionMessage);
                
                setTimeout(createCake, 2000);
            }
            
            function createCake() {
                isCakeActive = true;
                
                if (cakeMessage) {
                    cakeMessage.remove();
                }
                
                cakeMessage = document.createElement('div');
                cakeMessage.className = 'cake-message';
                cakeMessage.textContent = 'Тортик!';
                document.getElementById('container').appendChild(cakeMessage);
                
                const centerX = particlesCanvas.width / 2;
                const centerY = 200;
                const layers = 5;
                const particlesPerLayer = 100;
                
                const pinkColors = ['#FFB6C1', '#FF69B4', '#FF1493', '#DB7093', '#C71585'];
                const brownColors = ['#8B4513', '#A0522D', '#CD853F', '#D2691E', '#A52A2A'];
                
                const baseLayers = 6;
                const baseParticlesPerLayer = 50;
                const baseRadius = 105;
                
                for (let layer = 0; layer < baseLayers; layer++) {
                    const radius = baseRadius;
                    const yOffset = centerY + 28 + layer * 15;
                    
                    for (let i = 0; i < baseParticlesPerLayer; i++) {
                        const angle = (i / baseParticlesPerLayer) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = yOffset + Math.sin(angle) * (radius / 4);
                        
                        cakeParticles.push({
                            x: x,
                            y: y,
                            size: Math.random() * 4 + 3,
                            color: brownColors[Math.floor(Math.random() * brownColors.length)],
                            alpha: 1,
                            initialX: x,
                            initialY: y,
                            waveOffset: Math.random() * Math.PI * 2,
                            waveSpeed: 0.03 + Math.random() * 0.03,
                            waveAmount: 1 + Math.random() * 2,
                            isBase: true
                        });
                    }
                }
                
                for (let layer = 0; layer < layers; layer++) {
                    const radius = 100 - layer * 20;
                    const yOffset = centerY - layer * 15;
                    
                    for (let i = 0; i < particlesPerLayer; i++) {
                        const angle = (i / particlesPerLayer) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = yOffset + Math.sin(angle) * (radius / 3);
                        
                        cakeParticles.push({
                            x: x,
                            y: y,
                            size: Math.random() * 4 + 3,
                            color: pinkColors[Math.floor(Math.random() * pinkColors.length)],
                            alpha: 1,
                            initialX: x,
                            initialY: y,
                            waveOffset: Math.random() * Math.PI * 2,
                            waveSpeed: 0.05 + Math.random() * 0.05,
                            waveAmount: 2 + Math.random() * 3
                        });
                    }
                }
                
                const x = centerX;
                const y = centerY - layers * 15 - 20;
                
                cakeParticles.push({
                    x: x,
                    y: y,
                    size: 5,
                    color: '#FFFFFF',
                    alpha: 1,
                    initialX: x,
                    initialY: y,
                    waveOffset: Math.random() * Math.PI * 2,
                    waveSpeed: 0.03 + Math.random() * 0.03,
                    waveAmount: 1 + Math.random() * 2,
                    isCandle: true
                });
                
                cakeParticles.push({
                    x: x,
                    y: y - 12,
                    size: 6,
                    color: '#FFD700',
                    alpha: 1,
                    initialX: x,
                    initialY: y - 12,
                    waveOffset: Math.random() * Math.PI * 2,
                    waveSpeed: 0.1 + Math.random() * 0.1,
                    waveAmount: 3 + Math.random() * 2,
                    isFlame: true
                });
            }
            
            function updateCakeParticles() {
                const time = Date.now() * 0.001;
                
                cakeParticles.forEach(particle => {
                    particle.x = particle.initialX + Math.sin(time * particle.waveSpeed + particle.waveOffset) * particle.waveAmount;
                    
                    if (particle.isFlame) {
                        particle.y = particle.initialY + Math.sin(time * particle.waveSpeed * 2 + particle.waveOffset) * 2;
                        particle.alpha = 0.7 + Math.sin(time * 5) * 0.3;
                    } else {
                        particle.y = particle.initialY;
                    }
                });
            }
            

            function drawCakeParticles() {
                const time = Date.now() * 0.001;
                
                cakeParticles.forEach(particle => {
                    if (particle.alpha < 0.05) return;
                    
                    const gradient = particlesCtx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    
                    if (particle.isFlame) {

                        gradient.addColorStop(0, `${particle.color}${Math.round(particle.alpha * 255).toString(16).padStart(2, '0')}`);
                        gradient.addColorStop(0.5, `#FF4500${Math.round(particle.alpha * 180).toString(16).padStart(2, '0')}`);
                        gradient.addColorStop(1, `${particle.color}00`);
                    } else if (particle.isBase) {

                        gradient.addColorStop(0, `${particle.color}${Math.round(particle.alpha * 200).toString(16).padStart(2, '0')}`);
                        gradient.addColorStop(1, `${particle.color}00`);
                    } else {
                        gradient.addColorStop(0, `${particle.color}${Math.round(particle.alpha * 200).toString(16).padStart(2, '0')}`);
                        gradient.addColorStop(1, `${particle.color}00`);
                    }
                    
                    particlesCtx.beginPath();
                    particlesCtx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    particlesCtx.fillStyle = gradient;
                    particlesCtx.fill();
                    
                    particlesCtx.beginPath();
                    particlesCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    
                    if (particle.isFlame) {
                        particlesCtx.fillStyle = `#FFD700${Math.round(particle.alpha * 255).toString(16).padStart(2, '0')}`;
                    } else if (particle.isCandle) {
                        particlesCtx.fillStyle = `#FFFFFF${Math.round(particle.alpha * 255).toString(16).padStart(2, '0')}`;
                    } else if (particle.isBase) {
                        particlesCtx.fillStyle = `${particle.color}${Math.round(particle.alpha * 255).toString(16).padStart(2, '0')}`;
                    } else {
                        particlesCtx.fillStyle = `${particle.color}${Math.round(particle.alpha * 255).toString(16).padStart(2, '0')}`;
                    }
                    
                    particlesCtx.fill();
                });
            }
            
            function removeCompletionMessage() {
                if (completionMessage) {
                    completionMessage.remove();
                    completionMessage = null;
                }
                if (cakeMessage) {
                    cakeMessage.remove();
                    cakeMessage = null;
                }
            }
            
            function updateCounter() {
                counter.textContent = ``;
            }
            
            function createStarfield() {
                bgCtx.fillStyle = '#000';
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                
                const starCount = 500;
                for (let i = 0; i < starCount; i++) {
                    const x = Math.random() * bgCanvas.width;
                    const y = Math.random() * bgCanvas.height;
                    const radius = Math.random() * 0.8 + 0.2;
                    const alpha = Math.random() * 0.7 + 0.3;
                    
                    bgCtx.beginPath();
                    bgCtx.arc(x, y, radius, 0, Math.PI * 2);
                    bgCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    bgCtx.fill();
                }
                
                const gradient = bgCtx.createLinearGradient(0, 0, bgCanvas.width, 0);
                gradient.addColorStop(0, 'rgba(15, 15, 40, 0.3)');
                gradient.addColorStop(0.5, 'rgba(60, 30, 100, 0.6)');
                gradient.addColorStop(1, 'rgba(15, 15, 40, 0.3)');
                
                bgCtx.fillStyle = gradient;
                bgCtx.fillRect(0, bgCanvas.height * 0.4, bgCanvas.width, bgCanvas.height * 0.2);
            }
            
            let particles = [];
            
            function createParticles() {
                particles = [];
                
                for (let i = 0; i < config.particleCount; i++) {
                    particles.push({
                        x: Math.random() * particlesCanvas.width,
                        y: Math.random() * particlesCanvas.height,
                        size: Math.random() * (config.particleSize.max - config.particleSize.min) + config.particleSize.min,
                        color: config.colors[Math.floor(Math.random() * config.colors.length)],
                        speedX: (Math.random() - 0.5) * config.movementSpeed,
                        speedY: (Math.random() - 0.5) * config.movementSpeed,
                        alpha: Math.random() * 0.5 + 0.3,
                        targetX: 0,
                        targetY: 0,
                        isForming: false,
                        twinkleOffset: Math.random() * Math.PI * 2,
                        baseAlpha: Math.random() * 0.5 + 0.3
                    });
                }
            }
            
            function drawParticles() {
                particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
                
                const time = Date.now() * 0.001;
                
                particles.forEach(particle => {
                    if (particle.alpha < 0.05) return;
                    
                    const twinkle = Math.sin(time * config.twinkleSpeed + particle.twinkleOffset) * 0.3 + 0.7;
                    
                    const gradient = particlesCtx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    gradient.addColorStop(0, `${particle.color}${Math.round(particle.alpha * twinkle * 200).toString(16).padStart(2, '0')}`);
                    gradient.addColorStop(1, `${particle.color}00`);
                    
                    particlesCtx.beginPath();
                    particlesCtx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    particlesCtx.fillStyle = gradient;
                    particlesCtx.fill();
                    
                    particlesCtx.beginPath();
                    particlesCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    particlesCtx.fillStyle = `${particle.color}${Math.round(particle.alpha * 255).toString(16).padStart(2, '0')}`;
                    particlesCtx.fill();
                });
                
                if (isCakeActive) {
                    drawCakeParticles();
                }
            }
            
            function updateParticles() {
                const time = Date.now() * 0.001;
                
                particles.forEach(particle => {
                    if (isExploding) {
                        particle.x += particle.explosionVelX;
                        particle.y += particle.explosionVelY;
                        
                        particle.alpha = Math.max(0, particle.alpha - 0.01);
                        
                        particle.explosionVelY += 0.05;
                        
                        if (particle.x < 0 || particle.x > particlesCanvas.width) {
                            particle.explosionVelX *= -0.8;
                        }
                        if (particle.y < 0 || particle.y > particlesCanvas.height) {
                            particle.explosionVelY *= -0.8;
                        }
                    } else if (particle.isForming) {
                        particle.x += (particle.targetX - particle.x) * 0.1;
                        particle.y += (particle.targetY - particle.y) * 0.1;
                        
                        particle.x += Math.sin(time * 10 + particle.twinkleOffset) * 0.2;
                        particle.y += Math.cos(time * 8 + particle.twinkleOffset) * 0.2;
                        
                        particle.alpha = Math.min(0.9, particle.alpha + 0.05);
                    } else {
                        particle.x += particle.speedX + Math.sin(time + particle.twinkleOffset) * 0.1;
                        particle.y += particle.speedY + Math.cos(time * 1.5 + particle.twinkleOffset) * 0.1;
                        
                        particle.alpha = Math.max(0, particle.alpha - 0.02);
                        
                        if (particle.x < 0) particle.x = particlesCanvas.width;
                        if (particle.x > particlesCanvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = particlesCanvas.height;
                        if (particle.y > particlesCanvas.height) particle.y = 0;
                    }
                });
                
                if (isCakeActive) {
                    updateCakeParticles();
                }
                
                if (isExploding) {
                    const visibleParticles = particles.filter(p => p.alpha > 0.05).length;
                    if (visibleParticles === 0) {
                        isExploding = false;
                    }
                }
            }
            
            function animate() {
                updateParticles();
                drawParticles();
                requestAnimationFrame(animate);
            }
            
            function getTextPixels(text) {
                textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
                

                const fontSize = Math.min(200, textCanvas.width / (text.length * 0.8));
                textCtx.font = `900 ${fontSize}px 'Arial'`;
                textCtx.textAlign = 'center';
                textCtx.textBaseline = 'middle';
                textCtx.fillStyle = 'white';
                textCtx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);
                
                const imageData = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                const data = imageData.data;
                const pixels = [];
                

                const spacing = 8;
                
                for (let y = 0; y < textCanvas.height; y += spacing) {
                    for (let x = 0; x < textCanvas.width; x += spacing) {
                        const index = (y * textCanvas.width + x) * 4;
                        
                        if (data[index + 3] > 128) {
                            pixels.push({ x, y });
                        }
                    }
                }
                
                return pixels;
            }
            
            function animateText(text) {
                const newTextPixels = getTextPixels(text);
                
                currentTextPixels = newTextPixels;
                
                particles.forEach(particle => {
                    particle.isForming = false;
                });
                
                const reusableParticles = [];
                

                for (let i = 0; i < particles.length; i++) {
                    if (particles[i].isForming && particles[i].alpha > 0.5) {
                        reusableParticles.push(i);
                    }
                }
                
                const reuseCount = Math.min(reusableParticles.length, newTextPixels.length);
                for (let i = 0; i < reuseCount; i++) {
                    const particleIndex = reusableParticles[i];
                    const pixelIndex = i % newTextPixels.length;
                    
                    particles[particleIndex].targetX = newTextPixels[pixelIndex].x;
                    particles[particleIndex].targetY = newTextPixels[pixelIndex].y;
                    particles[particleIndex].isForming = true;
                }
                
                let assignedCount = reuseCount;
                for (let i = 0; i < particles.length && assignedCount < newTextPixels.length; i++) {
                    if (!particles[i].isForming) {
                        particles[i].targetX = newTextPixels[assignedCount].x;
                        particles[i].targetY = newTextPixels[assignedCount].y;
                        particles[i].isForming = true;
                        assignedCount++;
                    }
                }
            }
            
            function togglePause() {
                isPaused = !isPaused;
                
                if (isPaused) {
                    pauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    pauseBtn.title = "Resume";
                } else {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    pauseBtn.title = "Pause";
                    startAutoChange();
                }
            }
            
            function goToPreviousWord() {
                if (isExploding || animationCompleted) return;
                
                currentWordIndex = (currentWordIndex - 1 + spaceWords.length) % spaceWords.length;
                animateText(spaceWords[currentWordIndex]);
                updateCounter();
            }
            
            function restartAnimation() {
                currentWordIndex = 0;
                isPaused = false;
                isExploding = false;
                animationCompleted = false;
                isCakeActive = false;
                cakeParticles = [];
                
                removeCompletionMessage();
                
                pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                pauseBtn.title = "Pause";
                updateCounter();
                
                createParticles();
                
                animateText(spaceWords[currentWordIndex]);
                
                startAutoChange();
            }
            
            function setupEventListeners() {
                window.addEventListener('resize', () => {
                    resizeCanvases();
                    createStarfield();
                    createParticles();
                    if (!animationCompleted && !isExploding) {
                        animateText(spaceWords[currentWordIndex]);
                    }
                });
                
                pauseBtn.addEventListener('click', togglePause);
                
                prevBtn.addEventListener('click', goToPreviousWord);
                
                restartBtn.addEventListener('click', restartAnimation);
            }
            
            init();
            animate();
        }
        
        window.addEventListener('load', () => {
            setCanvasSize();
            createConfetti();
            animateConfetti();
            updateTimer();
            
            timerInterval = setInterval(updateTimer, 1000);
        });
      
        window.addEventListener('resize', setCanvasSize);
    </script>
</body>
</html>

